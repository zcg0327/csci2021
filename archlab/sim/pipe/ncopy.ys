#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len words to dst.
# Return the number of negative words (<0) contained in src.
#
# modified by Brady Olson 11/15/2016
#
# 1.	I used loop unrolling to increase the number of the number
#		of instructions per iteration. This takes a minor step in
#		reducing data dependencies. Note: I used an arbitrary size
#		of 10 elements per iteration since this seemed to be the
#		maximum allowed by file size.
# 2.	Expanding on the loop unrolling principles, I used two
#		temp registers (%r10 for src[i] and %r9 for src[i+1]).
#		This reduces bubbles in the frequent instruction sequence
#		of mrmov and rmmov by adding instructions between. This
#		costs one extra register, but eliminates several nops per
#		element.
# 3.	Using the iadd instruction from part (b) eliminates the
#		irmov add sequence from the original version. This is both
#		more effective in speed and register usage.
#		
#
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
ncopy:

##################################################################
 # data initialization / setup
	xorq	%rax, %rax		# %rax = count <- 0
	andq	%rdx, %rdx		# test if len < 0
	jle		Done			# if so, jump to end
	iaddq	$-10, %rdx		# len -= 10
	jl		Adjust			# if len now < 0 (ie. len < 10)
							# go to adjustment - skip loop

Loop:
	mrmovq	(%rdi), %r10	# %r10 <- src[0]
	mrmovq	8(%rdi), %r9	# %r9  <- src[1]
	rmmovq	%r10, (%rsi)	# dst[0] <- src[0]
	andq	%r10, %r10		# test if src[0] >= 0
	jge		Npos1			# if so, go to next element
	iaddq	$1, %rax		# if not, count += 1
Npos1:
	rmmovq	%r9, 8(%rsi)	# dst[1] <- src[1]
	andq	%r9, %r9		# test if src[1] >= 0
	jge		Npos2			# if so, go to next element
	iaddq	$1, %rax		# if not, count +=1
Npos2:
	mrmovq	16(%rdi), %r10	# %r10 <- src[2]
	mrmovq	24(%rdi), %r9	# %r9  <- src[3]
	rmmovq	%r10, 16(%rsi)	# dst[2] <- src[2]
	andq	%r10, %r10		# test if src[2] >= 0
	jge		Npos3			# if so, go to next element
	iaddq	$1, %rax		# if not, count += 1
Npos3:
	rmmovq	%r9, 24(%rsi)	# dst[3] <- src[3]
	andq	%r9, %r9		# test if src[3] >= 0
	jge		Npos4			# if so, go to next element
	iaddq	$1, %rax		# if not, count += 1
Npos4:
	mrmovq	32(%rdi), %r10	# %r10 <- src[4]
	mrmovq	40(%rdi), %r9	# ...
	rmmovq	%r10, 32(%rsi)
	andq	%r10, %r10
	jge		Npos5
	iaddq	$1, %rax
Npos5:
	rmmovq	%r9, 40(%rsi)
	andq	%r9, %r9
	jge		Npos6
	iaddq	$1, %rax
Npos6:
	mrmovq	48(%rdi), %r10
	mrmovq	56(%rdi), %r9
	rmmovq	%r10, 48(%rsi)
	andq	%r10, %r10
	jge		Npos7
	iaddq	$1, %rax
Npos7:
	rmmovq	%r9, 56(%rsi)
	andq	%r9, %r9
	jge		Npos8
	iaddq	$1, %rax
Npos8:
	mrmovq	64(%rdi), %r10
	mrmovq	72(%rdi), %r9
	rmmovq	%r10, 64(%rsi)
	andq	%r10, %r10
	jge		Npos9
	iaddq	$1, %rax
Npos9:
	rmmovq	%r9, 72(%rsi)
	andq	%r9, %r9
	jge		Cond
	iaddq	$1, %rax
Cond:
	iaddq	$80, %rdi		# src += 10
	iaddq	$80, %rsi		# dst += 10
	iaddq	$-10, %rdx		# len -= 10
	jge		Loop			# if len now >= 0, go to top of loop
Adjust:
	iaddq	$10, %rdx		# add 10 back to len
	addq	%rdx, %rdx
	addq	%rdx, %rdx
	addq	%rdx, %rdx
	mrmovq	JT(%rdx), %rdx	# %rdx = JT + 8*len

	pushq	%rdx			# instruction sequence to essentially
	ret						# jump to %rdx in memory and return

# body to copy & check remaining  < 10 elements
Xpos9:
	mrmovq	64(%rdi), %r10	# %r10 = val <- src[9]
	rmmovq	%r10, 64(%rsi)	# dst[9] <- src[9]
	andq	%r10, %r10		# test if src[9] >= 0
	jge		Xpos8			# if so, go to next element
	iaddq	$1, %rax		# if not, count+=1
Xpos8:
	mrmovq	56(%rdi), %r10	# %r10 = val <- src[8]
	rmmovq	%r10, 56(%rsi)	# ...
	andq	%r10, %r10
	jge		Xpos7
	iaddq	$1, %rax
Xpos7:
	mrmovq	48(%rdi), %r10
	rmmovq	%r10, 48(%rsi)
	andq	%r10, %r10
	jge		Xpos6
	iaddq	$1, %rax
Xpos6:
	mrmovq	40(%rdi), %r10
	rmmovq	%r10, 40(%rsi)
	andq	%r10, %r10
	jge		Xpos5
	iaddq	$1, %rax
Xpos5:
	mrmovq	32(%rdi), %r10
	rmmovq	%r10, 32(%rsi)
	andq	%r10, %r10
	jge		Xpos4
	iaddq	$1, %rax
Xpos4:
	mrmovq	24(%rdi), %r10
	rmmovq	%r10, 24(%rsi)
	andq	%r10, %r10
	jge		Xpos3
	iaddq	$1, %rax
Xpos3:
	mrmovq	16(%rdi), %r10
	rmmovq	%r10, 16(%rsi)
	andq	%r10, %r10
	jge		Xpos2
	iaddq	$1, %rax
Xpos2:
	mrmovq	8(%rdi), %r10
	rmmovq	%r10, 8(%rsi)
	andq	%r10, %r10
	jge		Xpos1
	iaddq	$1, %rax
Xpos1:
	mrmovq	(%rdi), %r10
	rmmovq	%r10, (%rsi)
	andq	%r10, %r10
	jge		Xpos0
	iaddq	$1, %rax
Xpos0:
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################

# jump table for number of remaining elements
# jump to Xposi if there are i elements remaining to copy & check
JT:	.quad Xpos0
	.quad Xpos1
	.quad Xpos2
	.quad Xpos3
	.quad Xpos4
	.quad Xpos5
	.quad Xpos6
	.quad Xpos7
	.quad Xpos8
	.quad Xpos9

# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
